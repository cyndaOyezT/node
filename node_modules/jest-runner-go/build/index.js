'use strict';

var _child_process = require('child_process');

var _throat = require('throat');

var _throat2 = _interopRequireDefault(_throat);

var _utils = require('./lib/utils');

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

class CancelRun extends Error {
  constructor(message) {
    super(message);
    this.name = 'CancelRun';
  }
}

class GoTestRunner {

  constructor(globalConfig) {
    this._globalConfig = globalConfig;
  }

  // eslint-disable-next-line max-len
  runTests(tests, watcher, onStart, onResult, onFailure) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const mutex = (0, _throat2.default)(_this._globalConfig.maxWorkers);
      return Promise.all(tests.map(function (test) {
        return mutex(_asyncToGenerator(function* () {
          if (watcher.isInterrupted()) {
            throw new CancelRun('watcher interupted');
          }

          yield onStart(test);

          return _this._runTest(test.path).then(function (result) {
            onResult(test, result);
          }).catch(function (error) {
            return onFailure(test, error);
          });
        }));
      }));
    })();
  }

  _runTest(testPath) {
    return _asyncToGenerator(function* () {
      const start = +new Date();

      return new Promise(function (resolve, reject) {
        const child = (0, _child_process.spawn)('go', ['test', `./...`]);

        let stdout = '';
        child.stdout.setEncoding('utf-8');
        // eslint-disable-next-line no-return-assign
        child.stdout.on('data', function (data) {
          return stdout += data;
        });
        child.stdout.on('error', function (error) {
          return reject(error);
        });
        child.stdout.on('close', function () {
          let result = [];

          try {
            result = stdout.toString().split('\n');
          } catch (error) {
            reject(error);
          }

          const report = (0, _utils.parseGoOutput)(testPath, start, result);
          const end = +new Date();

          report.end = end;
          report.duration = end - start;

          resolve({
            console: null,
            failureMessage: report.failed > 0 ? report.failureMessage : null,
            numFailingTests: report.failed || 0,
            numPassingTests: report.passed || 0,
            numPendingTests: 0,
            perfStats: {
              end: report.end,
              start
            },
            skipped: false,
            snapshot: {
              added: 0,
              fileDeleted: false,
              matched: 0,
              unchecked: 0,
              unmatched: 0,
              updated: 0
            },
            sourceMaps: {},
            testExecError: null,
            testFilePath: testPath,
            testResults: [(0, _utils.toTestResult)(report)]
          });
        });
      });
    })();
  }
}

module.exports = GoTestRunner;